<!DOCTYPE html>
<html>
<head>
    <title>畫出拋物線軌跡</title>
    <script src="https://code.jquery.com/jquery-3.0.0.js"></script>
    <!-- <script src="https://code.createjs.com/easeljs-0.8.2.min.js"></script> -->
</head>
<body>
    <canvas id="testCanvas" width="400" height="9048"></canvas>
<div>

</div>

<script type="text/javascript">
    var canvas = document.querySelector('#testCanvas');
    canvas.style.backgroundColor = 'lightgrey';
    var ctx = canvas.getContext('2d');

    var drawPath = function(list, color){
        if(!color)
            color = 'blue';
        else
            color = 'red';
        ctx.beginPath();
        list.forEach(function(obj, idx, all){
            if(idx === 0 && all.length === 1)
                return ctx.moveTo(obj.x, obj.y);
            if(idx === 0)
                return ctx.moveTo(obj.x, obj.y);
            return ctx.lineTo(obj.x, obj.y);
        });
        ctx.lineWidth = 10;
        ctx.strokeStyle = color;
        ctx.stroke();  
    };


    // 拋物線預測實驗
    var origin = {
        x: 50,
        y: canvas.height - 100
    };

    var gravity = 9.8;
    // var airFriction = 1.2;
    var mass = 10;
    var accelerate = {
        y: 3 * mass,  // 6 * 10
        x: 2 * mass  // 0.5 * 10
    };

    // util for 畫出拋物線軌跡! t: 相當於 Detla Time 也可以說是 Step
    var Common = {
        cal: function(totalPath, lastPos, lastAccelerate, t){
            lastPos.x += lastAccelerate.x * t;
            lastPos.y += lastAccelerate.y * t;
            lastAccelerate.y = lastAccelerate.y - lastAccelerate.gravity * t;

            // air friction
            // lastAccelerate.x = lastAccelerate.x - airFriction * t;
            // if(lastAccelerate.x <= 0) lastAccelerate.x = 0;

            totalPath.push({
                x: lastPos.x,
                y: canvas.height - lastPos.y
            });
        }
    };
    var calculatePath = function(step, origin, accelerate){
        var totalPath = [];
        var lastPos = {
            x: origin.x,
            y: origin.y
        };
        var lastAccelerate = {
            x: accelerate.x,
            y: accelerate.y,
            gravity: gravity
        };

        var hanlder = function(t){
            Common.cal(totalPath, lastPos, lastAccelerate, t);
            
        };

        // 直到超過場地
        for(var t = 0; lastPos.y > 0; t += step){
            hanlder(step);
        };

        return totalPath;
    };

    var update = (function(){
        // finaly( step by 60Hz) 60/60 => 1 Second 來算重力加速
        var totalPath = calculatePath(1/60, origin, accelerate);

        // animationPath
        var currentPath = [];
        var lastPos = {
            x: origin.x,
            y: origin.y
        };
        var lastAccelerate = {
            x: accelerate.x,
            y: accelerate.y,
            gravity: gravity
        };

        var $update = function(delta, totalTime){
            console.debug(delta, lastAccelerate.y);
            if(lastPos.y <= canvas.height)
                Common.cal(currentPath, lastPos, lastAccelerate, delta / 1000);
            drawPath(totalPath);
            drawPath(currentPath, 'red');
        };
        return $update;
    })();

    var lastTime = window.performance.now();
    var beginTime = lastTime;
    function tick(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        var current = window.performance.now();
        var delta = current - lastTime;
        lastTime = current;
        update(delta, current - beginTime);
        requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);

    // avoid delta time too large bug
    window.addEventListener('focus', function() {
        document.title = 'focused';
        lastTime = window.performance.now();
    });

    window.addEventListener('blur', function() {
        document.title = 'not focused';
    });
</script>
</body>
</html>
